<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Chapter 10: Dimensionality Reduction with PCA | Quanskill</title>
		<link
			href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&family=Source+Serif+4:ital,wght@0,400;0,600;1,400&display=swap"
			rel="stylesheet" />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
		<style>
			:root {
				--quanskill-blue: #0b2fa0;
				--quanskill-blue-dark: #081f6b;
				--quanskill-blue-light: #1a4fd0;
				--quanskill-orange: #ff9000;
				--quanskill-orange-dark: #e68200;
				--quanskill-orange-light: #ffab33;
				--text-primary: #1a1a2e;
				--text-secondary: #4a4a6a;
				--bg-primary: #fafbff;
				--bg-secondary: #ffffff;
				--bg-card: #ffffff;
				--border-color: #e8eaf6;
				--code-bg: #f5f7ff;
				--success: #10b981;
				--error: #ef4444;
				--ml-accent: #7c3aed;
				--gradient-blue: linear-gradient(135deg, #0b2fa0 0%, #1a4fd0 100%);
				--gradient-orange: linear-gradient(135deg, #ff9000 0%, #ffab33 100%);
			}

			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: "Source Serif 4", Georgia, serif;
				background: var(--bg-primary);
				color: var(--text-primary);
				line-height: 1.8;
				font-size: 17px;
			}

			.header {
				background: var(--gradient-blue);
				color: white;
				padding: 1rem 2rem;
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				z-index: 1000;
				box-shadow: 0 4px 20px rgba(11, 47, 160, 0.3);
			}

			.header-content {
				max-width: 1400px;
				margin: 0 auto;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.header-logo {
				font-family: "Space Grotesk", sans-serif;
				font-weight: 700;
				font-size: 1.5rem;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}

			.header-logo-icon {
				width: 32px;
				height: 32px;
				background: var(--quanskill-orange);
				border-radius: 6px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: 700;
			}

			.sidebar {
				position: fixed;
				left: 0;
				top: 60px;
				bottom: 0;
				width: 300px;
				background: var(--bg-secondary);
				border-right: 1px solid var(--border-color);
				overflow-y: auto;
				padding: 1.5rem 0;
				z-index: 900;
				transition: transform 0.3s ease;
			}

			.sidebar-header {
				padding: 0 1.5rem 1rem;
				border-bottom: 1px solid var(--border-color);
				margin-bottom: 1rem;
			}

			.logo {
				display: flex;
				align-items: center;
				gap: 0.5rem;
				margin-bottom: 0.5rem;
			}

			.logo-icon {
				width: 32px;
				height: 32px;
				background: var(--quanskill-orange);
				border-radius: 6px;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: 700;
				font-size: 1rem;
				color: white;
			}

			.logo-text {
				font-family: "Space Grotesk", sans-serif;
				font-size: 1.25rem;
				font-weight: 700;
				color: var(--quanskill-blue);
			}

			.chapter-title {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.75rem;
				text-transform: uppercase;
				letter-spacing: 0.1em;
				color: var(--text-secondary);
			}

			.nav-section {
				padding: 0.5rem 1.5rem;
			}

			.nav-section-title {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.7rem;
				text-transform: uppercase;
				letter-spacing: 0.1em;
				color: var(--text-secondary);
				padding: 0.5rem 1rem;
				font-weight: 600;
			}

			.nav-link {
				display: block;
				padding: 0.6rem 1rem;
				color: var(--text-secondary);
				text-decoration: none;
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.9rem;
				border-radius: 8px;
				margin-bottom: 0.25rem;
				transition: all 0.2s ease;
				border-left: 3px solid transparent;
			}

			.nav-link:hover {
				background: var(--code-bg);
				color: var(--quanskill-blue);
			}

			.nav-link.active {
				background: rgba(11, 47, 160, 0.1);
				color: var(--quanskill-blue);
				border-left-color: var(--quanskill-orange);
				font-weight: 500;
			}

			.main-content {
				margin-left: 300px;
				padding: 80px 2rem 4rem;
				max-width: calc(100% - 300px);
			}

			.content-wrapper {
				max-width: 850px;
				margin: 0 auto;
			}

			.hero {
				background: var(--gradient-blue);
				color: white;
				padding: 4rem 3rem;
				border-radius: 20px;
				margin-bottom: 3rem;
				position: relative;
				overflow: hidden;
			}

			.hero::before {
				content: "";
				position: absolute;
				top: -50%;
				right: -20%;
				width: 400px;
				height: 400px;
				background: var(--quanskill-orange);
				border-radius: 50%;
				opacity: 0.1;
			}

			.hero::after {
				content: "";
				position: absolute;
				bottom: -30%;
				left: -10%;
				width: 300px;
				height: 300px;
				background: white;
				border-radius: 50%;
				opacity: 0.05;
			}

			.hero-content {
				position: relative;
				z-index: 1;
			}

			.hero-badge {
				display: inline-block;
				background: var(--quanskill-orange);
				color: white;
				padding: 0.35rem 1rem;
				border-radius: 20px;
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.8rem;
				font-weight: 600;
				margin-bottom: 1rem;
			}

			.hero h1 {
				font-family: "Space Grotesk", sans-serif;
				font-size: 2.75rem;
				font-weight: 700;
				margin-bottom: 1rem;
				line-height: 1.2;
			}

			.hero-subtitle {
				font-size: 1.15rem;
				opacity: 0.9;
				max-width: 600px;
				line-height: 1.7;
			}

			.hero-quote {
				margin-top: 2rem;
				padding: 1.5rem;
				background: rgba(255, 255, 255, 0.1);
				border-left: 4px solid var(--quanskill-orange);
				border-radius: 0 12px 12px 0;
				font-style: italic;
			}

			.key-concepts {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
				gap: 1rem;
				margin: 2rem 0;
			}

			.concept-card {
				background: var(--bg-card);
				border: 1px solid var(--border-color);
				padding: 1.25rem;
				border-radius: 12px;
				transition: transform 0.2s, box-shadow 0.2s;
			}

			.concept-card:hover {
				transform: translateY(-4px);
				box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
			}

			.concept-card .icon {
				width: 40px;
				height: 40px;
				background: var(--gradient-orange);
				border-radius: 10px;
				display: flex;
				align-items: center;
				justify-content: center;
				margin-bottom: 0.75rem;
				font-size: 1.25rem;
			}

			.concept-card h5 {
				font-family: "Space Grotesk", sans-serif;
				font-size: 1rem;
				font-weight: 600;
				color: var(--text-primary);
				margin-bottom: 0.5rem;
			}

			.concept-card p {
				font-size: 0.9rem;
				color: var(--text-secondary);
				line-height: 1.5;
				margin-bottom: 0;
			}

			.section {
				background: var(--bg-card);
				border-radius: 16px;
				padding: 2.5rem;
				margin-bottom: 2rem;
				border: 1px solid var(--border-color);
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.03);
			}

			.section-header {
				display: flex;
				align-items: flex-start;
				gap: 1rem;
				margin-bottom: 2rem;
				padding-bottom: 1.5rem;
				border-bottom: 2px solid var(--border-color);
			}

			.section-number {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.9rem;
				font-weight: 700;
				color: white;
				background: var(--gradient-orange);
				padding: 0.5rem 1rem;
				border-radius: 8px;
				white-space: nowrap;
			}

			.section-header h2 {
				font-family: "Space Grotesk", sans-serif;
				font-size: 1.75rem;
				font-weight: 600;
				color: var(--quanskill-blue);
				line-height: 1.3;
			}

			.section h3 {
				font-family: "Space Grotesk", sans-serif;
				font-size: 1.35rem;
				font-weight: 600;
				color: var(--text-primary);
				margin: 2rem 0 1rem;
			}

			.section h4 {
				font-family: "Space Grotesk", sans-serif;
				font-size: 1.1rem;
				font-weight: 600;
				color: var(--text-primary);
				margin: 1.5rem 0 0.75rem;
			}

			.section p {
				margin-bottom: 1.25rem;
			}

			.definition-box {
				background: linear-gradient(
					135deg,
					rgba(11, 47, 160, 0.05) 0%,
					rgba(11, 47, 160, 0.02) 100%
				);
				border-left: 4px solid var(--quanskill-blue);
				padding: 1.5rem;
				border-radius: 0 12px 12px 0;
				margin: 1.5rem 0;
			}

			.definition-box .label {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.8rem;
				font-weight: 700;
				text-transform: uppercase;
				letter-spacing: 0.05em;
				color: var(--quanskill-blue);
				margin-bottom: 0.75rem;
				display: block;
			}

			.ml-box {
				background: linear-gradient(
					135deg,
					rgba(124, 58, 237, 0.08) 0%,
					rgba(124, 58, 237, 0.03) 100%
				);
				border-left: 4px solid var(--ml-accent);
				padding: 1.5rem;
				border-radius: 0 12px 12px 0;
				margin: 1.5rem 0;
			}

			.ml-box .label {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.8rem;
				font-weight: 700;
				text-transform: uppercase;
				letter-spacing: 0.05em;
				color: var(--ml-accent);
				margin-bottom: 0.75rem;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}

			.ml-box .label::before {
				content: "ü§ì";
			}

			.quanskill-box {
				background: linear-gradient(
					135deg,
					rgba(11, 47, 160, 0.1) 0%,
					rgba(255, 144, 0, 0.1) 100%
				);
				border: 2px solid var(--quanskill-blue);
				padding: 1.5rem;
				border-radius: 12px;
				margin: 1.5rem 0;
				position: relative;
			}

			.quanskill-box::before {
				content: "";
				position: absolute;
				top: 0;
				left: 0;
				right: 0;
				height: 4px;
				background: var(--gradient-orange);
				border-radius: 12px 12px 0 0;
			}

			.quanskill-box .label {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.8rem;
				font-weight: 700;
				text-transform: uppercase;
				letter-spacing: 0.05em;
				color: var(--quanskill-blue);
				margin-bottom: 0.75rem;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}

			.quanskill-box .label::before {
				content: "üéì";
			}

			.example-box {
				background: var(--code-bg);
				border: 1px solid var(--border-color);
				padding: 1.5rem;
				border-radius: 12px;
				margin: 1.5rem 0;
			}

			.example-box .label {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.8rem;
				font-weight: 700;
				text-transform: uppercase;
				letter-spacing: 0.05em;
				color: var(--quanskill-blue);
				margin-bottom: 0.75rem;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}

			.example-box .label::before {
				content: "√¢‚Äì¬∏";
				color: var(--quanskill-orange);
			}

			.note-box {
				background: linear-gradient(
					135deg,
					rgba(255, 144, 0, 0.08) 0%,
					rgba(255, 144, 0, 0.03) 100%
				);
				border-left: 4px solid var(--quanskill-orange);
				padding: 1.5rem;
				border-radius: 0 12px 12px 0;
				margin: 1.5rem 0;
			}

			.note-box .label {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.8rem;
				font-weight: 700;
				text-transform: uppercase;
				letter-spacing: 0.05em;
				color: var(--quanskill-orange-dark);
				margin-bottom: 0.75rem;
				display: block;
			}

			.realworld-box {
				background: linear-gradient(
					135deg,
					rgba(16, 185, 129, 0.08) 0%,
					rgba(16, 185, 129, 0.03) 100%
				);
				border-left: 4px solid var(--success);
				padding: 1.5rem;
				border-radius: 0 12px 12px 0;
				margin: 1.5rem 0;
			}

			.realworld-box .label {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.8rem;
				font-weight: 700;
				text-transform: uppercase;
				letter-spacing: 0.05em;
				color: var(--success);
				margin-bottom: 0.75rem;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}

			.realworld-box .label::before {
				content: "üéÅ";
			}

			code {
				font-family: "JetBrains Mono", monospace;
				background: var(--code-bg);
				padding: 0.2rem 0.4rem;
				border-radius: 4px;
				font-size: 0.9em;
				color: var(--quanskill-blue);
			}

			.math-display {
				overflow-x: auto;
				padding: 1rem;
				margin: 1rem 0;
				background: var(--code-bg);
				border-radius: 8px;
			}

			.katex-display {
				margin: 1rem 0 !important;
				overflow-x: auto;
				overflow-y: hidden;
			}

			.data-table,
			.comparison-table {
				width: 100%;
				border-collapse: collapse;
				margin: 1.5rem 0;
				font-size: 0.95rem;
			}

			.data-table th,
			.comparison-table th {
				background: var(--code-bg);
				font-family: "Space Grotesk", sans-serif;
				font-weight: 600;
				color: var(--quanskill-blue);
				padding: 0.75rem 1rem;
				text-align: left;
				border-bottom: 2px solid var(--border-color);
			}

			.data-table td,
			.comparison-table td {
				padding: 0.75rem 1rem;
				border-bottom: 1px solid var(--border-color);
			}

			.data-table tr:hover td,
			.comparison-table tr:hover td {
				background: rgba(11, 47, 160, 0.02);
			}

			.quiz-box {
				background: linear-gradient(135deg, #fef3c7 0%, #fef9e7 100%);
				border: 2px dashed var(--quanskill-orange);
				padding: 1.5rem;
				border-radius: 12px;
				margin: 2rem 0;
			}

			.quiz-box .label {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.9rem;
				font-weight: 700;
				color: var(--quanskill-orange-dark);
				margin-bottom: 1rem;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}

			.quiz-box .label::before {
				content: "üß†";
			}

			.quiz-question {
				font-weight: 600;
				margin-bottom: 1rem;
				color: var(--text-primary);
			}

			.quiz-options {
				display: flex;
				flex-direction: column;
				gap: 0.5rem;
			}

			.quiz-option {
				padding: 0.75rem 1rem;
				background: white;
				border: 2px solid var(--border-color);
				border-radius: 8px;
				cursor: pointer;
				transition: all 0.2s;
				font-family: "Space Grotesk", sans-serif;
			}

			.quiz-option:hover {
				border-color: var(--quanskill-blue);
				background: rgba(11, 47, 160, 0.05);
			}

			.quiz-option.correct {
				border-color: var(--success);
				background: rgba(16, 185, 129, 0.1);
			}
			.quiz-option.incorrect {
				border-color: var(--error);
				background: rgba(239, 68, 68, 0.1);
			}

			.quiz-feedback {
				margin-top: 1rem;
				padding: 1rem;
				border-radius: 8px;
				font-family: "Space Grotesk", sans-serif;
				display: none;
			}

			.quiz-feedback.show {
				display: block;
			}
			.quiz-feedback.correct {
				background: rgba(16, 185, 129, 0.1);
				color: var(--success);
			}
			.quiz-feedback.incorrect {
				background: rgba(239, 68, 68, 0.1);
				color: var(--error);
			}

			.demo-container {
				background: var(--bg-card);
				border: 2px solid var(--quanskill-blue);
				border-radius: 16px;
				padding: 2rem;
				margin: 2rem 0;
			}

			.demo-header {
				display: flex;
				align-items: center;
				gap: 0.5rem;
				margin-bottom: 1.5rem;
			}

			.demo-header h4 {
				font-family: "Space Grotesk", sans-serif;
				color: var(--quanskill-blue);
				font-size: 1.1rem;
			}

			.demo-header::before {
				content: "√¢≈°¬°";
			}

			.demo-controls {
				display: flex;
				flex-wrap: wrap;
				gap: 1.5rem;
				margin-bottom: 1.5rem;
				padding: 1rem;
				background: var(--code-bg);
				border-radius: 10px;
			}

			.control-group {
				display: flex;
				flex-direction: column;
				gap: 0.25rem;
			}

			.control-group label {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.85rem;
				color: var(--text-secondary);
			}

			.control-group input[type="range"] {
				width: 150px;
				height: 8px;
				border-radius: 4px;
				background: var(--border-color);
				outline: none;
				-webkit-appearance: none;
			}

			.control-group input[type="range"]::-webkit-slider-thumb {
				-webkit-appearance: none;
				width: 20px;
				height: 20px;
				border-radius: 50%;
				background: var(--quanskill-blue);
				cursor: pointer;
			}

			.demo-canvas {
				width: 100%;
				height: 350px;
				border: 1px solid var(--border-color);
				border-radius: 10px;
				background: white;
			}

			.demo-results {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
				gap: 1rem;
				margin-top: 1.5rem;
			}

			.result-item {
				background: var(--code-bg);
				padding: 1rem;
				border-radius: 10px;
				text-align: center;
			}

			.result-item .value {
				font-family: "JetBrains Mono", monospace;
				font-size: 1.5rem;
				font-weight: 700;
				color: var(--quanskill-blue);
			}

			.result-item .label {
				font-family: "Space Grotesk", sans-serif;
				font-size: 0.8rem;
				color: var(--text-secondary);
				margin-top: 0.25rem;
				text-transform: none;
				letter-spacing: normal;
			}

			.result-item .label::before {
				content: none;
			}

			.algorithm-box {
				background: #1e293b;
				color: white;
				padding: 1.5rem;
				border-radius: 12px;
				margin: 1.5rem 0;
			}

			.algorithm-box h4 {
				font-family: "Space Grotesk", sans-serif;
				color: var(--quanskill-orange);
				margin-bottom: 1rem;
				font-size: 1rem;
			}

			.algorithm-box ol {
				margin-left: 1.5rem;
			}

			.algorithm-box li {
				margin-bottom: 0.75rem;
				font-family: "JetBrains Mono", monospace;
				font-size: 0.9rem;
			}

			.mobile-menu-btn {
				display: none;
				position: fixed;
				top: 15px;
				left: 15px;
				z-index: 1001;
				background: var(--quanskill-blue);
				color: white;
				border: none;
				padding: 10px 15px;
				border-radius: 8px;
				cursor: pointer;
				font-size: 1.25rem;
			}

			@media (max-width: 1024px) {
				.sidebar {
					transform: translateX(-100%);
				}
				.sidebar.open {
					transform: translateX(0);
				}
				.main-content {
					margin-left: 0;
					max-width: 100%;
					padding: 80px 1.5rem 3rem;
				}
				.mobile-menu-btn {
					display: block;
				}
				.hero h1 {
					font-size: 2rem;
				}
				.section {
					padding: 1.5rem;
				}
				.progress-bar {
					left: 0;
				}
			}

			.progress-bar {
				position: fixed;
				top: 60px;
				left: 300px;
				right: 0;
				height: 3px;
				background: var(--border-color);
				z-index: 800;
			}

			.progress-fill {
				height: 100%;
				background: var(--gradient-orange);
				width: 0%;
				transition: width 0.1s;
			}

			ul,
			ol {
				margin: 1rem 0 1.5rem 1.5rem;
			}
			li {
				margin-bottom: 0.5rem;
			}
			li::marker {
				color: var(--quanskill-orange);
			}

			/* Floating Back to Main Button */
			.floating-back-btn {
				position: fixed;
				top: 75px;
				left: 15px;
				background: linear-gradient(135deg, #0b2fa0 0%, #1a4fd0 100%);
				color: white !important;
				padding: 0.6rem 1.2rem;
				border-radius: 25px;
				text-decoration: none !important;
				font-family: "Space Grotesk", sans-serif;
				font-weight: 600;
				font-size: 0.85rem;
				z-index: 9999;
				box-shadow: 0 4px 15px rgba(11, 47, 160, 0.3);
				transition: all 0.3s ease;
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}
			.floating-back-btn:hover {
				transform: translateY(-2px);
				box-shadow: 0 6px 20px rgba(11, 47, 160, 0.4);
				background: linear-gradient(135deg, #ff9000 0%, #e68200 100%);
			}
			@media (max-width: 900px) {
				.floating-back-btn {
					top: auto;
					bottom: 20px;
					left: 15px;
					right: auto;
					padding: 0.5rem 1rem;
					font-size: 0.8rem;
				}
			}
		</style>
	</head>
	<body>
		<!-- Floating Back to Main Page Button -->
		<a href="index.html" class="floating-back-btn">‚Üê Main Page</a>

		<header class="header">
			<div class="header-content">
				<button class="mobile-menu-btn" onclick="toggleSidebar()">‚ò∞</button>
			</div>
		</header>

		<div class="progress-bar">
			<div class="progress-fill" id="progressFill"></div>
		</div>

		<nav class="sidebar" id="sidebar">
			<div class="sidebar-header">
				<div class="logo">
					<div class="logo-icon">Q</div>
					<span class="logo-text">Quanskill</span>
				</div>
				<div class="chapter-title">Chapter 10 ¬∑ Dimensionality Reduction</div>
			</div>

			<div class="nav-section">
				<div class="nav-section-title">Overview</div>
				<a href="#intro" class="nav-link active">Introduction</a>
			</div>

			<div class="nav-section">
				<div class="nav-section-title">Core Concepts</div>
				<a href="#section-10-1" class="nav-link">Problem Setting</a>
				<a href="#section-10-2" class="nav-link"
					>Maximum Variance Perspective</a
				>
				<a href="#section-10-3" class="nav-link">Projection Perspective</a>
				<a href="#section-10-4" class="nav-link">PCA Algorithm</a>
			</div>

			<div class="nav-section">
				<div class="nav-section-title">Wrap Up</div>
				<a href="#summary" class="nav-link">Chapter Summary</a>
			</div>
		</nav>

		<main class="main-content">
			<div class="content-wrapper">
				<!-- Hero Section -->
				<section class="hero" id="intro">
					<div class="hero-content">
						<span class="hero-badge">Chapter 10</span>
						<h1>Dimensionality Reduction with PCA</h1>
						<p class="hero-subtitle">
							Learn to compress high-dimensional data while preserving essential
							information. Principal Component Analysis finds the directions of
							maximum variance in your data.
						</p>
						<div class="hero-quote">
							"PCA is like finding the most informative angle to photograph a
							sculpture ‚Äî capture the essence while discarding redundant views."
						</div>
					</div>
				</section>

				<!-- Key Concepts -->
				<div class="key-concepts">
					<div class="concept-card">
						<div class="icon">üìâ</div>
						<h5>Data Compression</h5>
						<p>Reduce dimensions while keeping important information</p>
					</div>
					<div class="concept-card">
						<div class="icon">üìä</div>
						<h5>Variance Maximization</h5>
						<p>Find directions with the largest data spread</p>
					</div>
					<div class="concept-card">
						<div class="icon">üéØ</div>
						<h5>Orthogonal Projection</h5>
						<p>Project data onto lower-dimensional subspaces</p>
					</div>
					<div class="concept-card">
						<div class="icon">üî¢</div>
						<h5>Eigendecomposition</h5>
						<p>Use eigenvalues to find principal components</p>
					</div>
					<div class="concept-card">
						<div class="icon">üîîÔøΩÔøΩ</div>
						<h5>Encoder-Decoder</h5>
						<p>Compress and reconstruct data linearly</p>
					</div>
					<div class="concept-card">
						<div class="icon">üìà</div>
						<h5>Explained Variance</h5>
						<p>Measure information retained after compression</p>
					</div>
				</div>

				<!-- Section 10.1: Problem Setting -->
				<section class="section" id="section-10-1">
					<div class="section-header">
						<span class="section-number">10.1</span>
						<h2>Problem Setting</h2>
					</div>

					<p>
						High-dimensional data ‚Äî like images, genomic sequences, or sensor
						readings ‚Äî is often <strong>overcomplete</strong>: many dimensions
						are redundant and can be explained by combinations of others.
						Dimensionality reduction exploits this structure to find a compact
						representation.
					</p>

					<div class="definition-box">
						<span class="label">Definition: PCA Problem</span>
						<p>
							Given data $\mathbf{x}_n \in \mathbb{R}^D$, find projections
							$\tilde{\mathbf{x}}_n$ that:
						</p>
						<ul>
							<li>
								Live in a lower-dimensional subspace $\mathcal{U} \subseteq
								\mathbb{R}^D$ with $\dim(\mathcal{U}) = M < D$
							</li>
							<li>Are as similar to the original data as possible</li>
						</ul>
					</div>

					<h3>The Compression Framework</h3>
					<p>We represent the low-dimensional code as:</p>
					<div class="math-display">
						$$\mathbf{z}_n = \mathbf{B}^\top \mathbf{x}_n \in \mathbb{R}^M$$
					</div>
					<p>
						where $\mathbf{B} = [\mathbf{b}_1, \ldots, \mathbf{b}_M] \in
						\mathbb{R}^{D \times M}$ is the projection matrix with orthonormal
						columns.
					</p>

					<div class="example-box">
						<span class="label">Example: Image Compression</span>
						<p>
							A 28√ó28 grayscale image (like MNIST digits) is a vector in
							$\mathbb{R}^{784}$. But digits don't occupy this entire space ‚Äî
							they lie on a much lower-dimensional manifold. PCA finds this
							structure.
						</p>
						<p>
							With just 50 principal components (93.6% reduction!), we can
							reconstruct digits with minimal visual loss.
						</p>
					</div>

					<h3>Encoder-Decoder View</h3>
					<p>Think of PCA as a linear autoencoder:</p>
					<ul>
						<li>
							<strong>Encoder:</strong> $\mathbf{z} = \mathbf{B}^\top
							\mathbf{x}$ ‚Äî compress $D$ dimensions to $M$
						</li>
						<li>
							<strong>Decoder:</strong> $\tilde{\mathbf{x}} =
							\mathbf{B}\mathbf{z}$ ‚Äî reconstruct back to $D$ dimensions
						</li>
					</ul>
					<p>The bottleneck $\mathbf{z}$ controls information flow.</p>

					<div class="ml-box">
						<span class="label">Why This Matters in ML</span>
						<p>
							PCA is the linear ancestor of autoencoders! Modern deep learning
							uses nonlinear encoders/decoders (VAEs, etc.), but the core idea
							of learning compressed representations comes directly from PCA.
						</p>
					</div>
				</section>

				<!-- Section 10.2: Maximum Variance Perspective -->
				<section class="section" id="section-10-2">
					<div class="section-header">
						<span class="section-number">10.2</span>
						<h2>Maximum Variance Perspective</h2>
					</div>

					<p>
						If we interpret "information" as how spread out the data is, then
						<strong>variance</strong> measures information content. PCA finds
						directions that maximize the variance of the projected data.
					</p>

					<h3>Finding the First Principal Component</h3>
					<p>
						We seek a unit vector $\mathbf{b}_1$ that maximizes the variance of
						the projected data:
					</p>
					<div class="math-display">
						$$V_1 = \mathbb{V}[z_1] = \frac{1}{N} \sum_{n=1}^{N} (z_{1n})^2 =
						\mathbf{b}_1^\top \mathbf{S} \mathbf{b}_1$$
					</div>
					<p>
						where $\mathbf{S} = \frac{1}{N} \sum_{n=1}^{N} \mathbf{x}_n
						\mathbf{x}_n^\top$ is the data covariance matrix (assuming centered
						data).
					</p>

					<div class="definition-box">
						<span class="label"
							>Theorem: Principal Components are Eigenvectors</span
						>
						<p>Using Lagrange multipliers to solve:</p>
						<div class="math-display">
							$$\max_{\mathbf{b}_1} \mathbf{b}_1^\top \mathbf{S} \mathbf{b}_1
							\quad \text{subject to} \quad \|\mathbf{b}_1\|^2 = 1$$
						</div>
						<p>
							We find that $\mathbf{b}_1$ is an <strong>eigenvector</strong> of
							$\mathbf{S}$:
						</p>
						<div class="math-display">
							$$\mathbf{S}\mathbf{b}_1 = \lambda_1 \mathbf{b}_1$$
						</div>
						<p>The variance equals the eigenvalue: $V_1 = \lambda_1$</p>
						<p>
							To maximize variance, choose the eigenvector with the
							<strong>largest eigenvalue</strong>.
						</p>
					</div>

					<!-- Interactive Demo: PCA Visualization -->
					<div class="demo-container">
						<div class="demo-header">
							<h4>Interactive: PCA on 2D Data</h4>
						</div>
						<div class="demo-controls">
							<div class="control-group">
								<label>Data Spread (x): <span id="spreadXVal">2.0</span></label>
								<input
									type="range"
									id="spreadXSlider"
									min="50"
									max="300"
									value="200" />
							</div>
							<div class="control-group">
								<label>Data Spread (y): <span id="spreadYVal">0.5</span></label>
								<input
									type="range"
									id="spreadYSlider"
									min="20"
									max="200"
									value="50" />
							</div>
							<div class="control-group">
								<label>Rotation: <span id="rotationVal">30¬∞</span></label>
								<input
									type="range"
									id="rotationSlider"
									min="0"
									max="90"
									value="30" />
							</div>
						</div>
						<canvas id="pcaCanvas" class="demo-canvas"></canvas>
						<div class="demo-results">
							<div class="result-item">
								<div class="value" id="var1">‚Äî</div>
								<div class="label">Œª√¢‚Äö¬Å (PC1 Variance)</div>
							</div>
							<div class="result-item">
								<div class="value" id="var2">‚Äî</div>
								<div class="label">Œª√¢‚Äö‚Äö (PC2 Variance)</div>
							</div>
							<div class="result-item">
								<div class="value" id="varExplained">‚Äî</div>
								<div class="label">Variance Explained by PC1</div>
							</div>
						</div>
					</div>

					<h3>Multiple Principal Components</h3>
					<p>
						The $m$th principal component is the eigenvector of $\mathbf{S}$
						associated with the $m$th largest eigenvalue. Total variance
						captured by $M$ components:
					</p>
					<div class="math-display">$$V_M = \sum_{m=1}^{M} \lambda_m$$</div>
					<p>Variance lost by compression:</p>
					<div class="math-display">
						$$J_M = \sum_{j=M+1}^{D} \lambda_j = V_D - V_M$$
					</div>

					<div class="note-box">
						<span class="label">Key Insight</span>
						<p>
							The eigenvalues tell us exactly how much variance each principal
							component captures. If the first few eigenvalues are much larger
							than the rest, the data has a strong low-dimensional structure
							that PCA can exploit.
						</p>
					</div>

					<div class="quiz-box">
						<span class="label">Quick Check</span>
						<p class="quiz-question">
							If a dataset's covariance matrix has eigenvalues [10, 5, 3, 1,
							0.5, 0.5], what fraction of variance is captured by the first 2
							principal components?
						</p>
						<div class="quiz-options">
							<div class="quiz-option" onclick="checkQuiz(this, false)">
								50%
							</div>
							<div class="quiz-option" onclick="checkQuiz(this, true)">75%</div>
							<div class="quiz-option" onclick="checkQuiz(this, false)">
								90%
							</div>
							<div class="quiz-option" onclick="checkQuiz(this, false)">
								15%
							</div>
						</div>
						<div class="quiz-feedback correct">
							Correct! Total variance = 10+5+3+1+0.5+0.5 = 20. First two
							components: 10+5 = 15. Ratio: 15/20 = 75%.
						</div>
						<div class="quiz-feedback incorrect">
							Not quite. Sum the first two eigenvalues and divide by the total
							sum of all eigenvalues.
						</div>
					</div>
				</section>

				<!-- Section 10.3: Projection Perspective -->
				<section class="section" id="section-10-3">
					<div class="section-header">
						<span class="section-number">10.3</span>
						<h2>Projection Perspective</h2>
					</div>

					<p>
						An alternative way to derive PCA: minimize the
						<strong>reconstruction error</strong> between original data and its
						projection.
					</p>

					<h3>Reconstruction Error Objective</h3>
					<p>We want projections $\tilde{\mathbf{x}}_n$ that minimize:</p>
					<div class="math-display">
						$$J_M = \frac{1}{N} \sum_{n=1}^{N} \|\mathbf{x}_n -
						\tilde{\mathbf{x}}_n\|^2$$
					</div>
					<p>
						where $\tilde{\mathbf{x}}_n = \sum_{m=1}^{M} z_{mn} \mathbf{b}_m =
						\mathbf{B}\mathbf{z}_n$
					</p>

					<div class="definition-box">
						<span class="label">Theorem: Optimal Projection is Orthogonal</span>
						<p>The optimal coordinates are:</p>
						<div class="math-display">
							$$z_{in} = \mathbf{b}_i^\top \mathbf{x}_n$$
						</div>
						<p>
							This is exactly the <strong>orthogonal projection</strong> of
							$\mathbf{x}_n$ onto the subspace spanned by $\mathbf{b}_i$.
						</p>
					</div>

					<h3>The Displacement Vector</h3>
					<p>
						The difference between original and projected data lies in the
						orthogonal complement:
					</p>
					<div class="math-display">
						$$\mathbf{x}_n - \tilde{\mathbf{x}}_n = \sum_{j=M+1}^{D}
						(\mathbf{x}_n^\top \mathbf{b}_j) \mathbf{b}_j$$
					</div>
					<p>This is the projection onto the subspace we're discarding.</p>

					<!-- Second Interactive Demo: Reconstruction -->
					<div class="demo-container">
						<div class="demo-header">
							<h4>Interactive: Projection & Reconstruction</h4>
						</div>
						<div class="demo-controls">
							<div class="control-group">
								<label
									>Components Used: <span id="componentsVal">1</span></label
								>
								<input
									type="range"
									id="componentsSlider"
									min="1"
									max="2"
									value="1" />
							</div>
							<div class="control-group">
								<label>Show Reconstruction Lines</label>
								<input type="checkbox" id="showLinesCheck" checked />
							</div>
						</div>
						<canvas id="reconstructCanvas" class="demo-canvas"></canvas>
						<div class="demo-results">
							<div class="result-item">
								<div class="value" id="reconError">‚Äî</div>
								<div class="label">Reconstruction Error</div>
							</div>
							<div class="result-item">
								<div class="value" id="compRatio">‚Äî</div>
								<div class="label">Compression Ratio</div>
							</div>
						</div>
					</div>

					<div class="note-box">
						<span class="label">Key Equivalence</span>
						<p>
							<strong>Maximizing variance</strong> in the projected space is
							equivalent to <strong>minimizing reconstruction error</strong>.
							Both lead to the same solution: eigenvectors of the covariance
							matrix!
						</p>
					</div>

					<div class="realworld-box">
						<span class="label">Real-World Applications</span>
						<ul>
							<li>
								<strong>Face recognition:</strong> "Eigenfaces" ‚Äî represent
								faces with ~100 components instead of thousands of pixels
							</li>
							<li>
								<strong>Gene expression:</strong> Find the main patterns in
								thousands of genes
							</li>
							<li>
								<strong>Finance:</strong> Identify key factors driving stock
								returns
							</li>
							<li>
								<strong>Image compression:</strong> JPEG uses a related
								technique (DCT)
							</li>
							<li>
								<strong>Noise reduction:</strong> Keep principal components,
								discard noise in smaller ones
							</li>
						</ul>
					</div>
				</section>

				<!-- Section 10.4: PCA Algorithm -->
				<section class="section" id="section-10-4">
					<div class="section-header">
						<span class="section-number">10.4</span>
						<h2>PCA Algorithm</h2>
					</div>

					<div class="algorithm-box">
						<h4>Algorithm: Principal Component Analysis</h4>
						<ol>
							<li>
								<strong>Center the data:</strong> $\bar{\mathbf{x}}_n =
								\mathbf{x}_n - \boldsymbol{\mu}$ where $\boldsymbol{\mu} =
								\frac{1}{N}\sum_n \mathbf{x}_n$
							</li>
							<li>
								<strong>Compute covariance matrix:</strong> $\mathbf{S} =
								\frac{1}{N}\sum_n \bar{\mathbf{x}}_n \bar{\mathbf{x}}_n^\top$
							</li>
							<li>
								<strong>Eigendecomposition:</strong> Find eigenvalues $\lambda_1
								\geq \lambda_2 \geq \ldots \geq \lambda_D$ and eigenvectors
								$\mathbf{b}_1, \ldots, \mathbf{b}_D$
							</li>
							<li>
								<strong>Select M components:</strong> Keep first $M$
								eigenvectors: $\mathbf{B} = [\mathbf{b}_1, \ldots,
								\mathbf{b}_M]$
							</li>
							<li>
								<strong>Project:</strong> $\mathbf{z}_n = \mathbf{B}^\top
								\bar{\mathbf{x}}_n$
							</li>
							<li>
								<strong>Reconstruct (optional):</strong> $\tilde{\mathbf{x}}_n =
								\mathbf{B}\mathbf{z}_n + \boldsymbol{\mu}$
							</li>
						</ol>
					</div>

					<h3>Choosing the Number of Components</h3>
					<p>Common strategies for selecting $M$:</p>
					<ul>
						<li>
							<strong>Explained variance threshold:</strong> Keep components
							until 95% (or 99%) of variance is explained
						</li>
						<li>
							<strong>Scree plot:</strong> Look for an "elbow" in the eigenvalue
							plot
						</li>
						<li>
							<strong>Cross-validation:</strong> Choose $M$ that minimizes
							reconstruction error on held-out data
						</li>
					</ul>

					<div class="example-box">
						<span class="label">Example: MNIST Digits</span>
						<p>For MNIST digit "8" (784 dimensions):</p>
						<ul>
							<li>First 50 components capture ~90% of variance</li>
							<li>First 100 components capture ~95% of variance</li>
							<li>Most eigenvalues after ~150 are nearly zero</li>
						</ul>
						<p>
							This suggests digits lie on a ~50-100 dimensional manifold within
							the 784D pixel space!
						</p>
					</div>

					<div class="quiz-box">
						<span class="label">Quick Check</span>
						<p class="quiz-question">
							Why must we center the data before applying PCA?
						</p>
						<div class="quiz-options">
							<div class="quiz-option" onclick="checkQuiz(this, false)">
								To make computations faster
							</div>
							<div class="quiz-option" onclick="checkQuiz(this, true)">
								So the covariance matrix correctly captures variance, not mean
								effects
							</div>
							<div class="quiz-option" onclick="checkQuiz(this, false)">
								To ensure eigenvalues are positive
							</div>
							<div class="quiz-option" onclick="checkQuiz(this, false)">
								To make the data fit in memory
							</div>
						</div>
						<div class="quiz-feedback correct">
							Correct! Without centering, the "covariance" matrix would also
							capture the mean, leading to a principal component pointing toward
							the data mean rather than the direction of maximum variance.
						</div>
						<div class="quiz-feedback incorrect">
							Not quite. Think about what the covariance matrix measures when
							data isn't centered at zero.
						</div>
					</div>

					<div class="ml-box">
						<span class="label">Why This Matters in ML</span>
						<p>
							<strong>PCA as preprocessing:</strong> Reduce feature dimensions
							before training classifiers. Speeds up training and can reduce
							overfitting by removing noise in small-variance directions.
						</p>
						<p>
							<strong>PCA for visualization:</strong> Project high-dimensional
							data to 2D or 3D for plotting and understanding clusters.
						</p>
					</div>
				</section>

				<!-- Summary Section -->
				<section class="section" id="summary">
					<div class="section-header">
						<span class="section-number">Summary</span>
						<h2>Chapter Summary</h2>
					</div>

					<h3>Key Equations</h3>
					<table class="data-table">
						<thead>
							<tr>
								<th>Concept</th>
								<th>Formula</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>Data Covariance</td>
								<td>
									$\mathbf{S} = \frac{1}{N}\sum_{n=1}^{N} \mathbf{x}_n
									\mathbf{x}_n^\top$
								</td>
							</tr>
							<tr>
								<td>Principal Component</td>
								<td>$\mathbf{S}\mathbf{b}_m = \lambda_m \mathbf{b}_m$</td>
							</tr>
							<tr>
								<td>Projection (encode)</td>
								<td>$\mathbf{z}_n = \mathbf{B}^\top \mathbf{x}_n$</td>
							</tr>
							<tr>
								<td>Reconstruction (decode)</td>
								<td>$\tilde{\mathbf{x}}_n = \mathbf{B}\mathbf{z}_n$</td>
							</tr>
							<tr>
								<td>Variance Captured</td>
								<td>$V_M = \sum_{m=1}^{M} \lambda_m$</td>
							</tr>
							<tr>
								<td>Reconstruction Error</td>
								<td>$J_M = \sum_{j=M+1}^{D} \lambda_j$</td>
							</tr>
						</tbody>
					</table>

					<h3>Core Concepts Recap</h3>
					<div class="key-concepts">
						<div class="concept-card">
							<div class="icon">1√Ø¬∏¬è√¢∆í¬£</div>
							<h5>Variance = Information</h5>
							<p>Maximize variance in low-D representation</p>
						</div>
						<div class="concept-card">
							<div class="icon">2√Ø¬∏¬è√¢∆í¬£</div>
							<h5>Eigenvectors</h5>
							<p>Principal components are eigenvectors of covariance matrix</p>
						</div>
						<div class="concept-card">
							<div class="icon">3√Ø¬∏¬è√¢∆í¬£</div>
							<h5>Eigenvalues</h5>
							<p>Eigenvalue = variance explained by that component</p>
						</div>
						<div class="concept-card">
							<div class="icon">4√Ø¬∏¬è√¢∆í¬£</div>
							<h5>Orthogonal Projection</h5>
							<p>PCA finds optimal linear projection</p>
						</div>
					</div>

					<div class="quanskill-box">
						<span class="label">Quanskill Learning Path</span>
						<p><strong>Next Steps:</strong></p>
						<ul>
							<li>
								üìä <strong>Chapter 11:</strong> Density Estimation with Gaussian
								Mixture Models
							</li>
							<li>üéØ <strong>Chapter 12:</strong> Classification with SVMs</li>
						</ul>
						<p><strong>Practice Projects:</strong></p>
						<ul>
							<li>Implement PCA from scratch using eigendecomposition</li>
							<li>Visualize MNIST digits in 2D using PCA</li>
							<li>Compare reconstruction quality vs. number of components</li>
							<li>Use PCA for noise reduction in images</li>
						</ul>
					</div>
				</section>
			</div>
		</main>

		<script>
			// Initialize KaTeX
			document.addEventListener("DOMContentLoaded", function () {
				renderMathInElement(document.body, {
					delimiters: [
						{ left: "$$", right: "$$", display: true },
						{ left: "\\[", right: "\\]", display: true },
						{ left: "$", right: "$", display: false },
						{ left: "\\(", right: "\\)", display: false },
					],
					throwOnError: false,
				});
			});

			function checkQuiz(element, isCorrect) {
				const quizBox = element.closest(".quiz-box");
				const options = quizBox.querySelectorAll(".quiz-option");
				const feedbacks = quizBox.querySelectorAll(".quiz-feedback");

				options.forEach((opt) => {
					opt.style.pointerEvents = "none";
					opt.classList.remove("correct", "incorrect");
				});

				if (isCorrect) {
					element.classList.add("correct");
					feedbacks[0].classList.add("show");
				} else {
					element.classList.add("incorrect");
					feedbacks[1].classList.add("show");
				}
			}

			function toggleSidebar() {
				document.getElementById("sidebar").classList.toggle("open");
			}

			window.addEventListener("scroll", () => {
				const winScroll = document.documentElement.scrollTop;
				const height =
					document.documentElement.scrollHeight -
					document.documentElement.clientHeight;
				const scrolled = (winScroll / height) * 100;
				document.getElementById("progressFill").style.width = scrolled + "%";
			});

			const sections = document.querySelectorAll(".section, .hero");
			const navLinks = document.querySelectorAll(".nav-link");

			window.addEventListener("scroll", () => {
				let current = "";
				sections.forEach((section) => {
					const sectionTop = section.offsetTop;
					if (scrollY >= sectionTop - 200) {
						current = section.getAttribute("id");
					}
				});

				navLinks.forEach((link) => {
					link.classList.remove("active");
					if (link.getAttribute("href") === "#" + current) {
						link.classList.add("active");
					}
				});
			});

			// ========== PCA DEMO ==========
			const pcaCanvas = document.getElementById("pcaCanvas");
			const pcaCtx = pcaCanvas.getContext("2d");

			let dataPoints = [];

			function generatePCAData(spreadX, spreadY, rotation) {
				dataPoints = [];
				const N = 100;
				const angle = (rotation * Math.PI) / 180;

				for (let i = 0; i < N; i++) {
					// Generate data along axes
					const x = (Math.random() - 0.5) * spreadX;
					const y = (Math.random() - 0.5) * spreadY;

					// Rotate
					const rx = x * Math.cos(angle) - y * Math.sin(angle);
					const ry = x * Math.sin(angle) + y * Math.cos(angle);

					dataPoints.push([rx, ry]);
				}
			}

			function computePCA(data) {
				const N = data.length;

				// Compute mean
				let meanX = 0,
					meanY = 0;
				data.forEach((p) => {
					meanX += p[0];
					meanY += p[1];
				});
				meanX /= N;
				meanY /= N;

				// Center data and compute covariance
				let sxx = 0,
					syy = 0,
					sxy = 0;
				data.forEach((p) => {
					const cx = p[0] - meanX;
					const cy = p[1] - meanY;
					sxx += cx * cx;
					syy += cy * cy;
					sxy += cx * cy;
				});
				sxx /= N;
				syy /= N;
				sxy /= N;

				// Eigenvalues of 2x2 matrix
				const trace = sxx + syy;
				const det = sxx * syy - sxy * sxy;
				const disc = Math.sqrt((trace * trace) / 4 - det);
				const lambda1 = trace / 2 + disc;
				const lambda2 = trace / 2 - disc;

				// First eigenvector
				let v1x, v1y;
				if (Math.abs(sxy) > 1e-10) {
					v1x = lambda1 - syy;
					v1y = sxy;
				} else {
					v1x = 1;
					v1y = 0;
				}
				const norm1 = Math.sqrt(v1x * v1x + v1y * v1y);
				v1x /= norm1;
				v1y /= norm1;

				// Second eigenvector (orthogonal)
				const v2x = -v1y;
				const v2y = v1x;

				return {
					mean: [meanX, meanY],
					eigenvalues: [lambda1, lambda2],
					eigenvectors: [
						[v1x, v1y],
						[v2x, v2y],
					],
				};
			}

			function drawPCA() {
				const width = (pcaCanvas.width = pcaCanvas.offsetWidth);
				const height = (pcaCanvas.height = pcaCanvas.offsetHeight);

				pcaCtx.clearRect(0, 0, width, height);

				const spreadX =
					parseInt(document.getElementById("spreadXSlider").value) / 100;
				const spreadY =
					parseInt(document.getElementById("spreadYSlider").value) / 100;
				const rotation = parseInt(
					document.getElementById("rotationSlider").value
				);

				document.getElementById("spreadXVal").textContent = spreadX.toFixed(1);
				document.getElementById("spreadYVal").textContent = spreadY.toFixed(1);
				document.getElementById("rotationVal").textContent = rotation + "¬∞";

				generatePCAData(spreadX, spreadY, rotation);
				const pca = computePCA(dataPoints);

				const centerX = width / 2;
				const centerY = height / 2;
				const scale = 100;

				// Draw axes
				pcaCtx.strokeStyle = "#e8eaf6";
				pcaCtx.lineWidth = 1;
				pcaCtx.beginPath();
				pcaCtx.moveTo(0, centerY);
				pcaCtx.lineTo(width, centerY);
				pcaCtx.moveTo(centerX, 0);
				pcaCtx.lineTo(centerX, height);
				pcaCtx.stroke();

				// Draw data points
				pcaCtx.fillStyle = "rgba(11, 47, 160, 0.5)";
				dataPoints.forEach((p) => {
					pcaCtx.beginPath();
					pcaCtx.arc(
						centerX + p[0] * scale,
						centerY - p[1] * scale,
						4,
						0,
						Math.PI * 2
					);
					pcaCtx.fill();
				});

				// Draw principal components
				const drawPC = (vec, lambda, color, label) => {
					const len = Math.sqrt(lambda) * scale * 2;
					pcaCtx.strokeStyle = color;
					pcaCtx.lineWidth = 3;
					pcaCtx.beginPath();
					pcaCtx.moveTo(centerX - vec[0] * len, centerY + vec[1] * len);
					pcaCtx.lineTo(centerX + vec[0] * len, centerY - vec[1] * len);
					pcaCtx.stroke();

					// Arrow head
					const arrowSize = 10;
					const endX = centerX + vec[0] * len;
					const endY = centerY - vec[1] * len;
					const angle = Math.atan2(-vec[1], vec[0]);
					pcaCtx.beginPath();
					pcaCtx.moveTo(endX, endY);
					pcaCtx.lineTo(
						endX - arrowSize * Math.cos(angle - 0.3),
						endY + arrowSize * Math.sin(angle - 0.3)
					);
					pcaCtx.moveTo(endX, endY);
					pcaCtx.lineTo(
						endX - arrowSize * Math.cos(angle + 0.3),
						endY + arrowSize * Math.sin(angle + 0.3)
					);
					pcaCtx.stroke();

					// Label
					pcaCtx.fillStyle = color;
					pcaCtx.font = "bold 14px Space Grotesk, sans-serif";
					pcaCtx.fillText(label, endX + 10, endY);
				};

				drawPC(pca.eigenvectors[0], pca.eigenvalues[0], "#ff9000", "PC1");
				drawPC(pca.eigenvectors[1], pca.eigenvalues[1], "#10b981", "PC2");

				// Update stats
				const totalVar = pca.eigenvalues[0] + pca.eigenvalues[1];
				document.getElementById("var1").textContent =
					pca.eigenvalues[0].toFixed(3);
				document.getElementById("var2").textContent =
					pca.eigenvalues[1].toFixed(3);
				document.getElementById("varExplained").textContent =
					((pca.eigenvalues[0] / totalVar) * 100).toFixed(1) + "%";
			}

			// ========== RECONSTRUCTION DEMO ==========
			const reconstructCanvas = document.getElementById("reconstructCanvas");
			const reconstructCtx = reconstructCanvas.getContext("2d");

			function drawReconstruction() {
				const width = (reconstructCanvas.width = reconstructCanvas.offsetWidth);
				const height = (reconstructCanvas.height =
					reconstructCanvas.offsetHeight);

				reconstructCtx.clearRect(0, 0, width, height);

				const numComponents = parseInt(
					document.getElementById("componentsSlider").value
				);
				const showLines = document.getElementById("showLinesCheck").checked;

				document.getElementById("componentsVal").textContent = numComponents;

				// Use data from PCA demo
				if (dataPoints.length === 0) {
					generatePCAData(2.0, 0.5, 30);
				}
				const pca = computePCA(dataPoints);

				const centerX = width / 2;
				const centerY = height / 2;
				const scale = 100;

				// Draw axes
				reconstructCtx.strokeStyle = "#e8eaf6";
				reconstructCtx.lineWidth = 1;
				reconstructCtx.beginPath();
				reconstructCtx.moveTo(0, centerY);
				reconstructCtx.lineTo(width, centerY);
				reconstructCtx.moveTo(centerX, 0);
				reconstructCtx.lineTo(centerX, height);
				reconstructCtx.stroke();

				// Draw PC1 direction
				const pc1 = pca.eigenvectors[0];
				reconstructCtx.strokeStyle = "rgba(255, 144, 0, 0.3)";
				reconstructCtx.lineWidth = 2;
				reconstructCtx.beginPath();
				reconstructCtx.moveTo(centerX - pc1[0] * 200, centerY + pc1[1] * 200);
				reconstructCtx.lineTo(centerX + pc1[0] * 200, centerY - pc1[1] * 200);
				reconstructCtx.stroke();

				// Project and reconstruct
				let totalError = 0;

				dataPoints.forEach((p) => {
					// Project onto PC(s)
					let rx = 0,
						ry = 0;
					for (let c = 0; c < numComponents; c++) {
						const pc = pca.eigenvectors[c];
						const proj = p[0] * pc[0] + p[1] * pc[1];
						rx += proj * pc[0];
						ry += proj * pc[1];
					}

					// Draw reconstruction line
					if (showLines) {
						reconstructCtx.strokeStyle = "rgba(124, 58, 237, 0.3)";
						reconstructCtx.lineWidth = 1;
						reconstructCtx.beginPath();
						reconstructCtx.moveTo(
							centerX + p[0] * scale,
							centerY - p[1] * scale
						);
						reconstructCtx.lineTo(centerX + rx * scale, centerY - ry * scale);
						reconstructCtx.stroke();
					}

					// Original point
					reconstructCtx.fillStyle = "rgba(11, 47, 160, 0.5)";
					reconstructCtx.beginPath();
					reconstructCtx.arc(
						centerX + p[0] * scale,
						centerY - p[1] * scale,
						4,
						0,
						Math.PI * 2
					);
					reconstructCtx.fill();

					// Reconstructed point
					reconstructCtx.fillStyle = "#ff9000";
					reconstructCtx.beginPath();
					reconstructCtx.arc(
						centerX + rx * scale,
						centerY - ry * scale,
						5,
						0,
						Math.PI * 2
					);
					reconstructCtx.fill();

					totalError += Math.pow(p[0] - rx, 2) + Math.pow(p[1] - ry, 2);
				});

				document.getElementById("reconError").textContent = (
					totalError / dataPoints.length
				).toFixed(4);
				document.getElementById("compRatio").textContent =
					(2 / numComponents).toFixed(1) + "x";
			}

			// Event listeners
			["spreadXSlider", "spreadYSlider", "rotationSlider"].forEach((id) => {
				document.getElementById(id).addEventListener("input", () => {
					drawPCA();
					drawReconstruction();
				});
			});

			document
				.getElementById("componentsSlider")
				.addEventListener("input", drawReconstruction);
			document
				.getElementById("showLinesCheck")
				.addEventListener("change", drawReconstruction);

			// Initialize
			window.addEventListener("load", () => {
				drawPCA();
				drawReconstruction();
			});

			window.addEventListener("resize", () => {
				drawPCA();
				drawReconstruction();
			});
		</script>
	</body>
</html>
